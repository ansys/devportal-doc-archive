{"embedded": false, "project": "PyAEDT", "release": "0.6.37", "version": "0.6.37", "last_updated": null, "copyright": "(c) 2022 ANSYS, Inc. All rights reserved", "master_doc": "index", "root_doc": "index", "use_opensearch": "", "docstitle": "PyAEDT", "shorttitle": "PyAEDT", "show_copyright": true, "show_search_summary": true, "show_sphinx": true, "has_source": true, "show_source": true, "sourcelink_suffix": ".txt", "file_suffix": ".fjson", "link_suffix": ".html", "script_files": ["_static/documentation_options.js", "_static/jquery.js", "_static/underscore.js", "_static/_sphinx_javascript_frameworks_compat.js", "_static/doctools.js", "_static/sphinx_highlight.js", "_static/clipboard.min.js", "_static/copybutton.js"], "language": "en", "css_files": ["_static/pygments.css", "_static/styles/pydata-sphinx-theme.css", "_static/copybutton.css", "_static/graphviz.css", "_static/css\\ansys_sphinx_theme.css", "_static/sg_gallery.css", "_static/sg_gallery-binder.css", "_static/sg_gallery-dataframe.css", "_static/sg_gallery-rendered-html.css"], "sphinx_version": "5.3.0", "sphinx_version_tuple": [5, 3, 0, "final", 0], "docutils_version_info": [0, 19, 0, "final", 0], "styles": ["styles/pydata-sphinx-theme.css"], "style": "styles/pydata-sphinx-theme.css", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"]], "builder": "json", "parents": [], "logo": "pyansys-logo-black-cropped.png", "favicon": "ansys-favicon.png", "html5_doctype": true, "theme_nosidebar": "false", "theme_sidebarwidth": "270", "theme_body_min_width": "360", "theme_body_max_width": "800", "theme_navigation_with_keys": "True", "theme_enable_search_shortcuts": "True", "theme_globaltoc_collapse": "true", "theme_globaltoc_includehidden": "false", "theme_globaltoc_maxdepth": "", "theme_sidebar_includehidden": "True", "theme_use_edit_page_button": true, "theme_external_links": "", "theme_bitbucket_url": "", "theme_github_url": "https://github.com/pyansys/pyaedt", "theme_gitlab_url": "", "theme_twitter_url": "", "theme_icon_links_label": "Icon Links", "theme_icon_links": [{"name": "Support", "url": "https://github.com/pyansys/pyaedt/discussions", "icon": "fa fa-comment fa-fw"}], "theme_google_analytics_id": "", "theme_favicons": "", "theme_show_prev_next": false, "theme_search_bar_text": "Search the docs ...", "theme_search_bar_position": "sidebar", "theme_collapse_navigation": true, "theme_navigation_depth": "4", "theme_show_nav_level": "1", "theme_show_toc_level": "1", "theme_navbar_align": "content", "theme_navbar_start": "navbar-logo.html", "theme_navbar_center": "navbar-nav.html", "theme_navbar_end": "theme-switcher.html, navbar-icon-links.html", "theme_left_sidebar_end": "sidebar-ethical-ads.html", "theme_footer_items": "copyright.html, sphinx-version.html", "theme_page_sidebar_items": "page-toc.html, edit-this-page.html", "theme_switcher": "", "theme_pygment_light_style": "tango", "theme_pygment_dark_style": "native", "theme_logo": "", "theme_logo_text": "", "theme_contact_mail": "", "theme_logo.link": "https://www.ansys.com/", "theme_show_breadcrumbs": true, "theme_show_icons": "True", "theme_hidden_icons": "", "theme_additional_breadcrumbs": [["PyAnsys", "https://docs.pyansys.com/"]], "github_user": "pyansys", "github_repo": "pyaedt", "github_version": "main", "doc_path": "doc/source", "copybutton_prompt_text": ">>> ?|\\.\\.\\. ", "copybutton_prompt_is_regexp": true, "copybutton_only_copy_prompt_lines": true, "copybutton_remove_prompts": true, "copybutton_copy_empty_lines": true, "copybutton_line_continuation_character": "", "copybutton_here_doc_delimiter": "", "copybutton_image_svg": "", "copybutton_selector": "div.highlight pre", "copybutton_format_func": "function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Removes excluded text from a Node.\n *\n * @param {Node} target Node to filter.\n * @param {string} exclude CSS selector of nodes to exclude.\n * @returns {DOMString} Text from `target` with text removed.\n */\nfunction filterText(target, exclude) {\n    const clone = target.cloneNode(true);  // clone as to not modify the live DOM\n    if (exclude) {\n        // remove excluded nodes\n        clone.querySelectorAll(exclude).forEach(node => node.remove());\n    }\n    return clone.innerText;\n}\n\n// Callback when a copy button is clicked. Will be passed the node that was clicked\n// should then grab the text and replace pieces of text that shouldn't be used in output\nfunction formatCopyText(textContent, copybuttonPromptText, isRegexp = false, onlyCopyPromptLines = true, removePrompts = true, copyEmptyLines = true, lineContinuationChar = \"\", hereDocDelim = \"\") {\n    var regexp;\n    var match;\n\n    // Do we check for line continuation characters and \"HERE-documents\"?\n    var useLineCont = !!lineContinuationChar\n    var useHereDoc = !!hereDocDelim\n\n    // create regexp to capture prompt and remaining line\n    if (isRegexp) {\n        regexp = new RegExp('^(' + copybuttonPromptText + ')(.*)')\n    } else {\n        regexp = new RegExp('^(' + escapeRegExp(copybuttonPromptText) + ')(.*)')\n    }\n\n    const outputLines = [];\n    var promptFound = false;\n    var gotLineCont = false;\n    var gotHereDoc = false;\n    const lineGotPrompt = [];\n    for (const line of textContent.split('\\n')) {\n        match = line.match(regexp)\n        if (match || gotLineCont || gotHereDoc) {\n            promptFound = regexp.test(line)\n            lineGotPrompt.push(promptFound)\n            if (removePrompts && promptFound) {\n                outputLines.push(match[2])\n            } else {\n                outputLines.push(line)\n            }\n            gotLineCont = line.endsWith(lineContinuationChar) & useLineCont\n            if (line.includes(hereDocDelim) & useHereDoc)\n                gotHereDoc = !gotHereDoc\n        } else if (!onlyCopyPromptLines) {\n            outputLines.push(line)\n        } else if (copyEmptyLines && line.trim() === '') {\n            outputLines.push(line)\n        }\n    }\n\n    // If no lines with the prompt were found then just use original lines\n    if (lineGotPrompt.some(v => v === true)) {\n        textContent = outputLines.join('\\n');\n    }\n\n    // Remove a trailing newline to avoid auto-running when pasting\n    if (textContent.endsWith(\"\\n\")) {\n        textContent = textContent.slice(0, -1)\n    }\n    return textContent\n}\n", "copybutton_exclude": ".linenos, .gp"}