{"parents": [{"link": "../../", "title": "Examples"}, {"link": "../", "title": "EMIT examples"}], "prev": {"link": "../", "title": "EMIT examples"}, "next": {"link": "../ComputeProtectionLevels/", "title": "EMIT: Compute receiver protection levels"}, "title": "EMIT: Compute required channel separation", "meta": null, "body": "<div class=\"sphx-glr-download-link-note admonition note\">\n<p class=\"admonition-title\">Note</p>\n<p>Click <a class=\"reference internal\" href=\"#sphx-glr-download-examples-07-emit-computechannelseparation-py\"><span class=\"std std-ref\">here</span></a>\nto download the full example code</p>\n</div>\n<section class=\"sphx-glr-example-title\" id=\"emit-compute-required-channel-separation\">\n<span id=\"sphx-glr-examples-07-emit-computechannelseparation-py\"></span><h1>EMIT: Compute required channel separation<a class=\"headerlink\" href=\"#emit-compute-required-channel-separation\" title=\"Permalink to this heading\">#</a></h1>\n<p>This example shows how you can use PyAEDT to open an AEDT project with\nan EMIT design and analyze the results to determine the required channel\nseparation for overlapping bands.\nThis example requires Ansys AEDT 2023 R2. Uncomment it and run on correct version.</p>\n<section id=\"perform-required-imports\">\n<h2>Perform required imports<a class=\"headerlink\" href=\"#perform-required-imports\" title=\"Permalink to this heading\">#</a></h2>\n<p>Perform required imports.</p>\n<div class=\"highlight-default notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">subprocess</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pyaedt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyaedt</span> <span class=\"kn\">import</span> <span class=\"n\">Emit</span>\n\n<span class=\"c1\"># # Check to see which Python libraries have been installed</span>\n<span class=\"c1\"># reqs = subprocess.check_output([sys.executable, &#39;-m&#39;, &#39;pip&#39;, &#39;freeze&#39;])</span>\n<span class=\"c1\"># installed_packages = [r.decode().split(&#39;==&#39;)[0] for r in reqs.split()]</span>\n\n<span class=\"c1\"># # Install required packages if they are not installed</span>\n<span class=\"c1\"># def install(package):</span>\n<span class=\"c1\">#     subprocess.check_call([sys.executable, &#39;-m&#39;, &#39;pip&#39;, &#39;install&#39;, package])</span>\n\n<span class=\"c1\"># # Install any missing libraries</span>\n<span class=\"c1\"># required_packages = [&#39;plotly&#39;, &#39;tqdm&#39;, &#39;matplotlib&#39;, &#39;numpy&#39;]</span>\n<span class=\"c1\"># for package in required_packages:</span>\n<span class=\"c1\">#     if package not in installed_packages:</span>\n<span class=\"c1\">#         install(package)</span>\n\n<span class=\"c1\"># # Import required modules</span>\n<span class=\"c1\"># import plotly.graph_objects as go</span>\n<span class=\"c1\"># from tqdm.notebook import tqdm</span>\n\n<span class=\"c1\"># from matplotlib import pyplot as plt</span>\n<span class=\"c1\"># plt.ion() # Enables interactive mode so plots show immediately</span>\n<span class=\"c1\"># plt.show()</span>\n<span class=\"c1\"># import numpy as np</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Set non-graphical mode</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Set non-graphical mode. ``&quot;PYAEDT_NON_GRAPHICAL&quot;``` is needed to generate</span>\n<span class=\"c1\"># # documentation only.</span>\n<span class=\"c1\"># # You can set ``non_graphical`` either to ``True`` or ``False``.</span>\n<span class=\"c1\"># # The ``NewThread`` Boolean variable defines whether to create a new instance</span>\n<span class=\"c1\"># # of AEDT or try to connect to existing instance of it if one is available.</span>\n\n<span class=\"c1\"># non_graphical = os.getenv(&quot;PYAEDT_NON_GRAPHICAL&quot;, &quot;False&quot;).lower() in (&quot;true&quot;, &quot;1&quot;, &quot;t&quot;)</span>\n<span class=\"c1\"># NewThread = False</span>\n<span class=\"c1\"># desktop_version = &quot;2023.2&quot;</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Launch AEDT with EMIT</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Launch AEDT with EMIT. The ``Desktop`` class initializes AEDT and starts it</span>\n<span class=\"c1\"># # on the specified version and in the specified graphical mode.</span>\n\n<span class=\"c1\"># d = pyaedt.launch_desktop(desktop_version, non_graphical, NewThread)</span>\n<span class=\"c1\"># emitapp = Emit(pyaedt.generate_unique_project_name())</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Create and connect EMIT components</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Set up the scenario with radios connected to antennas.</span>\n\n<span class=\"c1\"># bluetooth, blue_ant = emitapp.modeler.components.create_radio_antenna(&quot;Bluetooth Low Energy (LE)&quot;, &quot;Bluetooth&quot;)</span>\n<span class=\"c1\"># gps, gps_ant = emitapp.modeler.components.create_radio_antenna(&quot;GPS Receiver&quot;, &quot;GPS&quot;)</span>\n<span class=\"c1\"># wifi, wifi_ant = emitapp.modeler.components.create_radio_antenna(&quot;WiFi - 802.11-2012&quot;, &quot;WiFi&quot;)</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Configure the radios</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Enable the HR-DSSS bands for the wifi radio and set the power level</span>\n<span class=\"c1\"># # for all transmit bands to simulate coupling.</span>\n\n<span class=\"c1\"># wifi_sampling = wifi.get_sampling()</span>\n<span class=\"c1\"># wifi_sampling.set_channel_sampling(percentage=25)</span>\n<span class=\"c1\"># for band in wifi.bands():</span>\n<span class=\"c1\">#     if &quot;HR-DSSS&quot; in band.node_name:</span>\n<span class=\"c1\">#         band.enabled=True</span>\n<span class=\"c1\">#         band.set_band_power_level(-50)</span>\n\n<span class=\"c1\"># # Reduce the bluetooth transmit power</span>\n<span class=\"c1\"># blue_sampling = bluetooth.get_sampling()</span>\n<span class=\"c1\"># blue_sampling.set_channel_sampling(percentage=50)</span>\n<span class=\"c1\"># for band in bluetooth.bands():</span>\n<span class=\"c1\">#     band.set_band_power_level(-50)</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Load the results set</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Create a results revision and load it for analysis.</span>\n\n<span class=\"c1\"># rev = emitapp.analyze()</span>\n<span class=\"c1\"># modeRx = emitapp.tx_rx_mode().rx</span>\n<span class=\"c1\"># modeTx = emitapp.tx_rx_mode().tx</span>\n<span class=\"c1\"># modeEmi = emitapp.result_type().emi</span>\n\n<span class=\"c1\"># def get_rx_bands(rx_radio):</span>\n<span class=\"c1\">#     &quot;&quot;&quot;Return a list of all Rx bands in a given radio.</span>\n<span class=\"c1\">#     Returns:</span>\n<span class=\"c1\">#         List of (&quot;Rx Radio Name&quot;, &quot;Rx Band Name&quot;) tuples.</span>\n<span class=\"c1\">#     &quot;&quot;&quot;</span>\n<span class=\"c1\">#     bands = emitapp.results.get_band_names(rx_radio, modeRx)</span>\n<span class=\"c1\">#     return [(rx_radio, band) for band in bands]</span>\n\n<span class=\"c1\"># def overlapping_tx_bands(rx_band):</span>\n<span class=\"c1\">#     &quot;&quot;&quot;Return a list of all Tx bands overlapping a given Rx band.</span>\n<span class=\"c1\">#     Returns:</span>\n<span class=\"c1\">#        List of (&quot;Tx Radio Name&quot;, &quot;Tx Band Name&quot;) tuples.</span>\n<span class=\"c1\">#     Argments:</span>\n<span class=\"c1\">#        rx_band: Rx band, given as a tuple (&quot;Rx Radio Name&quot;, &quot;Rx Band Name&quot;).</span>\n<span class=\"c1\">#     &quot;&quot;&quot;</span>\n<span class=\"c1\">#     overlapping = []</span>\n<span class=\"c1\">#     rx_frequencies = emitapp.results.get_active_frequencies(</span>\n<span class=\"c1\">#         rx_band[0], rx_band[1], modeRx</span>\n<span class=\"c1\">#     )</span>\n<span class=\"c1\">#     if len(rx_frequencies) &lt; 1:</span>\n<span class=\"c1\">#         return overlapping</span>\n<span class=\"c1\">#     rx_start = min(rx_frequencies)</span>\n<span class=\"c1\">#     rx_stop = max(rx_frequencies)</span>\n<span class=\"c1\">#     for tx_radio in emitapp.results.get_radio_names(modeTx):</span>\n<span class=\"c1\">#         if tx_radio == rx_band[0]:</span>\n<span class=\"c1\">#             # skip self interaction</span>\n<span class=\"c1\">#             continue</span>\n<span class=\"c1\">#         for tx_band in emitapp.results.get_band_names(tx_radio, modeTx):</span>\n<span class=\"c1\">#             tx_frequencies = emitapp.results.get_active_frequencies(</span>\n<span class=\"c1\">#                 tx_radio, tx_band, modeTx</span>\n<span class=\"c1\">#             )</span>\n<span class=\"c1\">#             tx_start = min(tx_frequencies)</span>\n<span class=\"c1\">#             tx_stop = max(tx_frequencies)</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\">#             def fuzzy_in_range(val, range_start, range_stop):</span>\n<span class=\"c1\">#                 return (</span>\n<span class=\"c1\">#                     (val &gt;= range_start and val &lt;= range_stop)</span>\n<span class=\"c1\">#                     or abs(val - range_start) &lt; 1.0</span>\n<span class=\"c1\">#                     or abs(val - range_stop) &lt; 1.0</span>\n<span class=\"c1\">#                 )</span>\n<span class=\"c1\">#             if (</span>\n<span class=\"c1\">#                 fuzzy_in_range(tx_start, rx_start, rx_stop)</span>\n<span class=\"c1\">#                 or fuzzy_in_range(tx_stop, rx_start, rx_stop)</span>\n<span class=\"c1\">#                 or fuzzy_in_range(rx_start, tx_start, tx_stop)</span>\n<span class=\"c1\">#                 or fuzzy_in_range(rx_stop, tx_start, tx_stop)</span>\n<span class=\"c1\">#             ):</span>\n<span class=\"c1\">#                 overlapping.append((tx_radio, tx_band))</span>\n<span class=\"c1\">#     return overlapping</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Iterate over all the receivers</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Iterates over each of the receivers in the project and finds any transmit</span>\n<span class=\"c1\"># # bands that contain overlapping channel frequencies.</span>\n<span class=\"c1\"># overlapping = []</span>\n<span class=\"c1\"># for rx_radio in emitapp.results.get_radio_names(modeRx):</span>\n<span class=\"c1\">#     print(&quot;Potential in-band issues for Rx Radio: {}&quot;.format(rx_radio))</span>\n<span class=\"c1\">#     for rx_band in get_rx_bands(rx_radio):</span>\n<span class=\"c1\">#         tx_bands = overlapping_tx_bands(rx_band)</span>\n<span class=\"c1\">#         if len(tx_bands) &lt; 1:</span>\n<span class=\"c1\">#             print(&#39;    Rx Band &quot;{}&quot; has no overlapping Tx bands&#39;.format(rx_band[1]))</span>\n<span class=\"c1\">#             continue</span>\n<span class=\"c1\">#         print(</span>\n<span class=\"c1\">#             &#39;    Rx band &quot;{}&quot; has the following overlapping Tx bands:&#39;.format(rx_band[1])</span>\n<span class=\"c1\">#         )</span>\n<span class=\"c1\">#         for tx_band in tx_bands:</span>\n<span class=\"c1\">#             overlapping.append((rx_band, tx_band))</span>\n<span class=\"c1\">#             print(&#39;        {}&#39;.format(tx_band))</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Print a list of overlapping bands</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Prints a list of overlapping receivers and bands.</span>\n<span class=\"c1\"># print(overlapping[0][0])</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Analyze the results</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Consider any EMI margin of 0dB or greater an interference issue.</span>\n\n<span class=\"c1\"># verbose = False</span>\n<span class=\"c1\"># threshold = 0.</span>\n\n<span class=\"c1\"># def minimum_tx_channel_separation(rx_band, tx_band, emi_threshold):</span>\n<span class=\"c1\">#     &quot;&quot;&quot;Return the minimum separation the Tx must be operated at for interference-free</span>\n<span class=\"c1\">#     operation of the Rx.</span>\n<span class=\"c1\">#     Returns:</span>\n<span class=\"c1\">#         Separation in MHz.</span>\n<span class=\"c1\">#     Arguments:</span>\n<span class=\"c1\">#         rx_band: Rx band, given as a tuple: (&quot;Rx Radio Name&quot;, &quot;Rx Band Name&quot;).</span>\n<span class=\"c1\">#         tx_band: Tx band, given as a tuple: (&quot;Tx Radio Name&quot;, &quot;Tx Band Name&quot;).</span>\n<span class=\"c1\">#         emi_threshold: Tx channel separation to be determined such that the EMI</span>\n<span class=\"c1\">#         margin is not at or above this level.</span>\n<span class=\"c1\">#     &quot;&quot;&quot;</span>\n\n<span class=\"c1\">#     domain = emitapp.interaction_domain()</span>\n<span class=\"c1\">#     domain.set_receiver(rx_band[0], rx_band[1], 0.0)</span>\n<span class=\"c1\">#     radTx = []</span>\n<span class=\"c1\">#     bandTx = []</span>\n<span class=\"c1\">#     chanTx = []</span>\n<span class=\"c1\">#     radTx.append(tx_band[0])</span>\n<span class=\"c1\">#     bandTx.append(tx_band[1])</span>\n<span class=\"c1\">#     chanTx.append(0.0)</span>\n<span class=\"c1\">#     domain.set_interferers(radTx, bandTx, chanTx)</span>\n\n<span class=\"c1\">#     interaction = rev.run(domain)</span>\n<span class=\"c1\">#     worst = interaction.get_worst_instance(modeEmi)</span>\n<span class=\"c1\">#     # If the worst case for the band-pair is below the EMI limit, then</span>\n<span class=\"c1\">#     # there are no interference issues and no offset is required.</span>\n<span class=\"c1\">#     if worst.has_valid_values():</span>\n<span class=\"c1\">#         emi = worst.get_value(modeEmi)</span>\n<span class=\"c1\">#         if emi &lt; emi_threshold:</span>\n<span class=\"c1\">#             return 0.0</span>\n<span class=\"c1\">#     # Assess each Rx channel and see how close the Tx can be tuned while</span>\n<span class=\"c1\">#     # keeping the EMI below the threshold.</span>\n<span class=\"c1\">#     # Freqs are used to set the domain, so they need to be in Hz</span>\n<span class=\"c1\">#     rx_frequencies = emitapp.results.get_active_frequencies(</span>\n<span class=\"c1\">#         rx_band[0], rx_band[1], modeRx, &quot;Hz&quot;</span>\n<span class=\"c1\">#     )</span>\n<span class=\"c1\">#     rx_channel_count = len(rx_frequencies)</span>\n<span class=\"c1\">#     tx_frequencies = emitapp.results.get_active_frequencies(</span>\n<span class=\"c1\">#         tx_band[0], tx_band[1], modeTx, &quot;Hz&quot;</span>\n<span class=\"c1\">#     )</span>\n<span class=\"c1\">#     tx_channel_count = len(tx_frequencies)</span>\n<span class=\"c1\">#     chpair = domain</span>\n<span class=\"c1\">#     offset_by_rx_freq = {}</span>\n<span class=\"c1\">#     for rx_frequency in rx_frequencies:</span>\n<span class=\"c1\">#         required_offset = 0.0</span>\n<span class=\"c1\">#         chpair.set_receiver(rx_band[0], rx_band[1], rx_frequency)</span>\n<span class=\"c1\">#         for tx_frequency in tx_frequencies:</span>\n<span class=\"c1\">#             chanTx = []</span>\n<span class=\"c1\">#             chanTx.append(tx_frequency)</span>\n<span class=\"c1\">#             chpair.set_interferers(radTx, bandTx, chanTx)</span>\n<span class=\"c1\">#             chpair_interaction = rev.run(chpair)</span>\n<span class=\"c1\">#             chpair_result = chpair_interaction.get_worst_instance(modeEmi)</span>\n<span class=\"c1\">#             if chpair_result.has_valid_values():</span>\n<span class=\"c1\">#                 emi = chpair_result.get_value(modeEmi)</span>\n<span class=\"c1\">#             else:</span>\n<span class=\"c1\">#                 emi = 300.0</span>\n<span class=\"c1\">#             if emi &gt;= emi_threshold:</span>\n<span class=\"c1\">#                 current_offset = abs(tx_frequency - rx_frequency)</span>\n<span class=\"c1\">#                 if current_offset &gt; required_offset and verbose:</span>\n<span class=\"c1\">#                     print(</span>\n<span class=\"c1\">#                         &quot;Interference between Tx {} and Rx {} is {}&quot;.format(</span>\n<span class=\"c1\">#                             tx_frequency, rx_frequency, emi</span>\n<span class=\"c1\">#                         )</span>\n<span class=\"c1\">#                     )</span>\n<span class=\"c1\">#                 required_offset = max(required_offset, current_offset)</span>\n<span class=\"c1\">#         offset_by_rx_freq[rx_frequency / 1.e6] = required_offset / 1.e6</span>\n<span class=\"c1\">#     return offset_by_rx_freq</span>\n\n<span class=\"c1\"># separation_results = []</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Plot the channel separation data</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # For each overlapping transmit/receive band combination, plot the required</span>\n<span class=\"c1\"># # separation for each channel.</span>\n<span class=\"c1\"># num=1 # Current figure number</span>\n<span class=\"c1\"># for rx_band, tx_band in tqdm(overlapping[1:]):</span>\n<span class=\"c1\">#     tx_frequencies = emitapp.results.get_active_frequencies(tx_band[0], tx_band[1], modeTx)</span>\n<span class=\"c1\">#     rx_frequencies = emitapp.results.get_active_frequencies(rx_band[0], rx_band[1], modeRx)</span>\n<span class=\"c1\">#     print(&#39;Rx:&#39;)</span>\n<span class=\"c1\">#     print(&#39;    Radio:&#39;, rx_band[0])</span>\n<span class=\"c1\">#     print(&#39;    Band:&#39;, rx_band[1])</span>\n<span class=\"c1\">#     print(&#39;    Channels: {} [{}, {}]&#39;.format(len(rx_frequencies), min(rx_frequencies), max(rx_frequencies)))</span>\n<span class=\"c1\">#     print(&#39;Tx:&#39;)</span>\n<span class=\"c1\">#     print(&#39;    Radio:&#39;, tx_band[0])</span>\n<span class=\"c1\">#     print(&#39;    Band:&#39;, tx_band[1])</span>\n<span class=\"c1\">#     print(&#39;    Channels: {} [{}, {}]&#39;.format(len(tx_frequencies), min(tx_frequencies), max(tx_frequencies)))</span>\n<span class=\"c1\">#     channel_pairs = len(tx_frequencies)*len(rx_frequencies)</span>\n<span class=\"c1\">#     print(&#39;Channel pairs: &#39;, channel_pairs)</span>\n<span class=\"c1\">#     if (channel_pairs &gt; 10000):</span>\n<span class=\"c1\">#         print(&#39;--- Skipping large band pair ---&#39;)</span>\n<span class=\"c1\">#         continue</span>\n<span class=\"c1\">#     separation = minimum_tx_channel_separation(rx_band, tx_band, threshold)</span>\n<span class=\"c1\">#     rx_separation_pairs = sorted(separation.items())</span>\n<span class=\"c1\">#     x, y = zip(*rx_separation_pairs)</span>\n<span class=\"c1\">#     plt.figure(num)</span>\n<span class=\"c1\">#     num=num+1</span>\n<span class=\"c1\">#     plt.plot(x, y, &#39;bo&#39;)</span>\n<span class=\"c1\">#     plt.xlabel(&#39;Rx Channel (MHz)&#39;)</span>\n<span class=\"c1\">#     plt.ylabel(&#39;Tx Separation (MHz)&#39;)</span>\n<span class=\"c1\">#     plt.title(&#39;Separation for {} and {}&#39;.format(rx_band, tx_band))</span>\n<span class=\"c1\">#     plt.grid()</span>\n<span class=\"c1\">#     plt.draw()</span>\n<span class=\"c1\">#     plt.pause(0.001) # needed to allow GUI events to occur</span>\n<span class=\"c1\">#     separation_results.append((rx_band, tx_band, max(y)))</span>\n\n<span class=\"c1\"># def remove_duplicates(a_list):</span>\n<span class=\"c1\">#     &quot;&quot;&quot;Remove duplicate values from a list.</span>\n<span class=\"c1\">#     Returns:</span>\n<span class=\"c1\">#         List with duplicate values removed.</span>\n<span class=\"c1\">#         a_list: List of tuples.</span>\n<span class=\"c1\">#     &quot;&quot;&quot;</span>\n<span class=\"c1\">#     ret = []</span>\n<span class=\"c1\">#     for a in a_list:</span>\n<span class=\"c1\">#         if a not in ret:</span>\n<span class=\"c1\">#             ret.append(a)</span>\n<span class=\"c1\">#     return ret</span>\n\n<span class=\"c1\"># def show_separation_table(separation_results, title=&#39;In-band Separation (MHz)&#39;):</span>\n<span class=\"c1\">#     &quot;&quot;&quot;Create a scenario matrix-like table to display the maximum</span>\n<span class=\"c1\">#     channel separate required for each transmit/receive band combination.</span>\n<span class=\"c1\">#     Arguments:</span>\n<span class=\"c1\">#         separation_results: Tuple of {Rx_Band, Tx_Band, max_channel_separation}.</span>\n<span class=\"c1\">#         title: Title of the table.</span>\n<span class=\"c1\">#     &quot;&quot;&quot;</span>\n<span class=\"c1\">#     rx_bands = remove_duplicates([rx_band for rx_band, tx_band, sep in separation_results])</span>\n<span class=\"c1\">#     tx_bands = remove_duplicates([tx_band for rx_band, tx_band, sep in separation_results])</span>\n<span class=\"c1\">#     header_values = [&#39;&lt;b&gt;Tx / Rx&lt;/b&gt;&#39;]</span>\n<span class=\"c1\">#     header_values.extend(rx_bands)</span>\n\n<span class=\"c1\">#     def get_separation(rx_band, tx_band):</span>\n<span class=\"c1\">#         for rxb, txb, sep in separation_results:</span>\n<span class=\"c1\">#             if txb==tx_band and rxb==rx_band:</span>\n<span class=\"c1\">#                 return sep</span>\n<span class=\"c1\">#         return &#39;N/A&#39;</span>\n\n<span class=\"c1\">#     rows = []</span>\n<span class=\"c1\">#     colors = []</span>\n<span class=\"c1\">#     for tx_band in tx_bands:</span>\n<span class=\"c1\">#         row = []</span>\n<span class=\"c1\">#         color = []</span>\n<span class=\"c1\">#         for rx_band in rx_bands:</span>\n<span class=\"c1\">#             sep = get_separation(rx_band, tx_band)</span>\n<span class=\"c1\">#             row.append(sep)</span>\n<span class=\"c1\">#             if isinstance(sep, float):</span>\n<span class=\"c1\">#                 if sep &lt;= 1.:</span>\n<span class=\"c1\">#                     color.append(&#39;yellow&#39;)</span>\n<span class=\"c1\">#                 elif sep &gt; 1.:</span>\n<span class=\"c1\">#                     color.append(&#39;orange&#39;)</span>\n<span class=\"c1\">#                 else:</span>\n<span class=\"c1\">#                     color.append(&#39;white&#39;)</span>\n<span class=\"c1\">#             else:</span>\n<span class=\"c1\">#                 color.append(&#39;white&#39;)</span>\n<span class=\"c1\">#         rows.append(row)</span>\n<span class=\"c1\">#         colors.append(color)</span>\n<span class=\"c1\">#     values = [tx_bands]</span>\n<span class=\"c1\">#     values.extend(rows)</span>\n\n<span class=\"c1\">#     val_colors = [[&#39;white&#39; for _ in tx_bands]]</span>\n<span class=\"c1\">#     val_colors.extend(colors)</span>\n<span class=\"c1\">#     fig = go.Figure(data=[go.Table(</span>\n<span class=\"c1\">#         header=dict(</span>\n<span class=\"c1\">#             values=header_values,</span>\n<span class=\"c1\">#             line_color=&#39;darkslategray&#39;,</span>\n<span class=\"c1\">#             fill_color=&#39;grey&#39;,</span>\n<span class=\"c1\">#             align=[&#39;left&#39;,&#39;center&#39;],</span>\n<span class=\"c1\">#             font=dict(color=&#39;darkslategray&#39;,size=16)</span>\n<span class=\"c1\">#         ),</span>\n<span class=\"c1\">#         cells=dict(</span>\n<span class=\"c1\">#             values=values,</span>\n<span class=\"c1\">#             line_color=&#39;darkslategray&#39;,</span>\n<span class=\"c1\">#             fill_color=val_colors,</span>\n<span class=\"c1\">#             align = [&#39;left&#39;, &#39;center&#39;],</span>\n<span class=\"c1\">#             font = dict(</span>\n<span class=\"c1\">#                 color = [&#39;darkslategray&#39;,&#39;black&#39;],</span>\n<span class=\"c1\">#                 size = 15)</span>\n<span class=\"c1\">#         )</span>\n<span class=\"c1\">#     )])</span>\n<span class=\"c1\">#     fig.update_layout(</span>\n<span class=\"c1\">#         title=dict(</span>\n<span class=\"c1\">#             text=title,</span>\n<span class=\"c1\">#             font=dict(color=&#39;darkslategray&#39;,size=20),</span>\n<span class=\"c1\">#             x = 0.5</span>\n<span class=\"c1\">#         ),</span>\n<span class=\"c1\">#         width = 800</span>\n<span class=\"c1\">#         )</span>\n<span class=\"c1\">#     fig.show()</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Show results for bluetooth receiver</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # Show the minimum required channel separation for the Bluetooth receiver.</span>\n<span class=\"c1\"># rx2_results = [x for x in separation_results if &#39;Bluetooth&#39; in x[1][0]]</span>\n\n<span class=\"c1\"># # Create a table</span>\n<span class=\"c1\"># show_separation_table(rx2_results, title=&#39;Separation for Bluetooth and WiFi (MHz)&#39;)</span>\n\n<span class=\"c1\"># # Need this to ensure plots don&#39;t close</span>\n<span class=\"c1\"># input(&quot;Press [enter] to continue.&quot;)</span>\n\n<span class=\"c1\"># ###############################################################################</span>\n<span class=\"c1\"># # Save project and close AEDT</span>\n<span class=\"c1\"># # ~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>\n<span class=\"c1\"># # After the simulation completes, you can close AEDT or release it using the</span>\n<span class=\"c1\"># # :func:`pyaedt.Desktop.force_close_desktop` method.</span>\n<span class=\"c1\"># # All methods provide for saving the project before closing.</span>\n\n<span class=\"c1\"># emitapp.save_project()</span>\n<span class=\"c1\"># emitapp.release_desktop(close_projects=True, close_desktop=True)</span>\n</pre></div>\n</div>\n<p class=\"sphx-glr-timing\"><strong>Total running time of the script:</strong> ( 0 minutes  0.000 seconds)</p>\n<div class=\"sphx-glr-footer sphx-glr-footer-example docutils container\" id=\"sphx-glr-download-examples-07-emit-computechannelseparation-py\">\n<div class=\"sphx-glr-download sphx-glr-download-python docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/66ea2156c3d20322b162d036270aea24/ComputeChannelSeparation.py\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Python</span> <span class=\"pre\">source</span> <span class=\"pre\">code:</span> <span class=\"pre\">ComputeChannelSeparation.py</span></code></a></p>\n</div>\n<div class=\"sphx-glr-download sphx-glr-download-jupyter docutils container\">\n<p><a class=\"reference download internal\" download=\"\" href=\"../../../_downloads/a94d11f04b4c9ef063171f532b529e9e/ComputeChannelSeparation.ipynb\"><code class=\"xref download docutils literal notranslate\"><span class=\"pre\">Download</span> <span class=\"pre\">Jupyter</span> <span class=\"pre\">notebook:</span> <span class=\"pre\">ComputeChannelSeparation.ipynb</span></code></a></p>\n</div>\n</div>\n<p class=\"sphx-glr-signature\"><a class=\"reference external\" href=\"https://sphinx-gallery.github.io\">Gallery generated by Sphinx-Gallery</a></p>\n</section>\n</section>\n", "metatags": "<meta name=\"generator\" content=\"Docutils 0.19: https://docutils.sourceforge.io/\" />\n", "rellinks": [["genindex", "General Index", "I", "index"], ["py-modindex", "Python Module Index", "", "modules"], ["examples/07-EMIT/ComputeProtectionLevels", "EMIT: Compute receiver protection levels", "N", "next"], ["examples/07-EMIT/index", "EMIT examples", "P", "previous"]], "sourcename": "examples/07-EMIT/ComputeChannelSeparation.rst.txt", "toc": "<ul>\n<li><a class=\"reference internal\" href=\"#\">EMIT: Compute required channel separation</a><ul>\n<li><a class=\"reference internal\" href=\"#perform-required-imports\">Perform required imports</a></li>\n</ul>\n</li>\n</ul>\n", "display_toc": true, "page_source_suffix": ".rst", "current_page_name": "examples/07-EMIT/ComputeChannelSeparation", "sidebars": ["search-field.html", "sidebar-nav-bs.html"], "customsidebar": null, "favicon_url": null, "logo_url": null, "alabaster_version": "0.7.13", "theme_show_toc_level": 1, "theme_logo": {}}